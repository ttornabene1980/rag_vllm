from fastapi import FastAPI
from fastapi.params import Query
from langchain.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# import dspy
from langchain.tools import Tool, tool
import requests
from bs4 import BeautifulSoup
from langchain_community.utilities import SQLDatabase
from langchain_community.agent_toolkits import create_sql_agent

# from guardrails import Guard
from langchain.agents import initialize_agent, AgentType
from langchain.agents import AgentExecutor
import psycopg2
from langchain.callbacks.base import BaseCallbackHandler

class SQLLogger(BaseCallbackHandler):
    def on_tool_end(self, serialized, **kwargs):
        # 'serialized' contains the SQL generated by the tool
        print("Generated SQL:", serialized)




app = FastAPI()

llm = ChatOpenAI(
    model="deepseek-coder-1.3b-instruct",
    openai_api_base="http://192.168.1.98:8000/v1",
    openai_api_key="EMPTY",  # vllm ignores this
    verbose=True
)
db: SQLDatabase = SQLDatabase.from_uri(
    "postgresql+psycopg2://sorgente:sorgente@192.168.1.98:5432/sorgente"
)
sql_agent_executor = create_sql_agent(
        llm=llm,
        db=db,
        agent_type="openai-functions",
        verbose=True
        )
sql_agent_executor.callbacks = [SQLLogger()]


def db_test():
    global db
    try:
        print("Connection testing!")
        tables = db.get_table_names()
        selectTest = db.run("SELECT 1")
        print("SQLAlchemy connection successful!", tables, selectTest)
        conn = psycopg2.connect(
            host="192.168.1.98",
            port=5432,
            dbname="sorgente",
            user="sorgente",
            password="sorgente",
        )
        print("Connection successful!")
        conn.close()
    except Exception as e:
        print("Connection failed:", e)


# @tool("ping")
# def ping_tool() -> str:
#     """Simple ping tool that returns 'pong'."""
#     return "pong"

# @tool("crawl_web")
# def crawl_web(url: str) -> str:
#     """Fetch and extract text from a web page"""
#     resp = requests.get(url, timeout=10)
#     soup = BeautifulSoup(resp.text, "html.parser")
#     return soup.get_text()[:2000]  # limit for token safety



# tools = [
#     ping_tool,
#     crawl_web
#     # , sql_agent_executor
# ]

# agent = initialize_agent(
#     tools, llm, agent=AgentType.OPENAI_FUNCTIONS,  verbose=True
# )
# agent: AgentExecutor = initialize_agent(
#     tools=tools,
#     llm=llm,
#     agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
#     verbose=True,
#     tool_choice="auto",
#     enable_auto_tool_choice=True,
#     tool_call_parser=True,
# )


@app.get("/sql-test")
async def run_sql():
    print("Testing SQL connection...")
    try:
        db_test()
        return {"status": "success"}
    except Exception as e:
        print("error", e)
        return {"error": str(e)}


@app.get("/sql-agent")
async def run_sql(query: str = Query(..., description="Natural language question")):
    print("Execute a natural language query on the SQL database.", query)
    global sql_agent_executor
    try:
        # sql = sql_agent_executor.plan(query)
        # print("Generated SQL:", sql)

        result = sql_agent_executor.invoke(query)
        print("result sql_agent_executor", result)
        print(result)
        return {"query": query, "result": result}
    except Exception as e:
        print("error", e)
        return {"error": str(e)}


@app.get("/langchain")
def use_langchain(query: str):
    prompt = PromptTemplate(
        template="Write a Python function that {task}", input_variables=["task"]
    )
    chain = prompt | llm
    return {"result": chain.invoke({"task": query})}


# Define a simple Guardrail schema
rail_spec = """
# Output must be JSON with:
{
  "function_name": "str",
  "code": "str"
}
"""

# llm = VLLM(model="TheBloke/Llama-2-7b-chat-hf", trust_remote_code=True)

# guard = Guard.from_rail_string(rail_spec, llm=llm)

# class FunctionWriter(dspy.Signature):
#     task = dspy.InputField()
#     code = dspy.OutputField()

# def generate_code(task: str) -> str:
#     response = guard(task)
#     return response["code"]

# generator = dspy.ChainOfThought(FunctionWriter, fn=generate_code)
# print(generator(task="reverse a string").code)


# sql_agent_executor = create_sql_agent(llm=llm, db=db, agent_type="openai-tools"  , verbose=True)


# //crawl_web
# tools = [sql_agent_executor]
# agent = initialize_agent(
#     tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True
# )


# # DSPy -> same vLLM endpoint
# dspy.settings.configure(
#     lm=dspy.LM("openai/deepseek-coder-1.3b",
#                api_base="http://vllm-deepseek:8000/v1",
#                api_key="EMPTY")
# )

# @app.geresult": response }

# @app.get("/dspy")
# def use_dspy(query: str):
#     class FunctionWriter(dspy.Signature):
#         """Write a Python function."""
#         task = dspy.InputField()
#         code = dspy.OutputField()
#     generator = dspy.ChainOfThought(FunctionWriter)
#     return {"result": generator(task=query).code}
