from fastapi import FastAPI
from fastapi.params import Query
from langchain.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
from langchain.callbacks import StdOutCallbackHandler

# import dspy
from langchain.tools import Tool, tool
import requests
from bs4 import BeautifulSoup
from langchain_community.utilities import SQLDatabase
from langchain_community.agent_toolkits import create_sql_agent

# from guardrails import Guard
from langchain.agents import initialize_agent, AgentType
from langchain.agents import AgentExecutor
import psycopg2
from langchain.callbacks.base import BaseCallbackHandler


class SQLLogger(BaseCallbackHandler):
    def on_tool_end(self, serialized, **kwargs):
        # 'serialized' contains the SQL generated by the tool
        print("Generated SQL:", serialized)


# 1️⃣ Capture reasoning in a variable
class ReasoningLogger(BaseCallbackHandler):
    def __init__(self):
        self.logs = []

    def on_agent_action(self, action, **kwargs):
        # Capture the Thought/Action/Action Input
        d = {"tool": action.tool, "tool_input": action.tool_input, "log": action.log}
        # print("Agent action:", d)
        self.logs.append(d)

    def on_agent_finish(self, finish, **kwargs):
        self.logs.append({"final_answer": finish.return_values})


app = FastAPI()

CUSTOM_SQL_PROMPT = """You are an expert SQL assistant.
You have access to the following tools:
{tools}

Your task is to answer SQL questions step by step.
Use ONLY the tool(s): {tool_names}.
Output MUST strictly follow this **EXACT FORMAT** for every step:

Question: <the user question>
Thought: <reasoning about what query to run next>
Action: {tool_names}
Action Input: <SQL query to execute>
Observation: <result returned by {tool_names}>
...repeat Thought/Action/Observation as needed...
Final Answer: <final answer in natural language>

IMPORTANT RULES:
- NEVER invent tool names or actions other than {tool_names}
- ALWAYS provide SQL queries in Action Input; never in natural language
- Use database schema if provided
- Avoid unsafe operations unless explicitly allowed (no DROP, DELETE, UPDATE)
- Final Answer must be present at the end
- Maintain this format strictly to ensure the output can be parsed

EXAMPLE OF CORRECT FORMAT:

Question: What are the fields in table persona?
Thought: I need to describe the table to see all columns
Action: {tool_names}
Action Input: "DESCRIBE persona;"
Observation: The table persona has columns: id, name, age, email
Final Answer: The table persona has the columns: id, name, age, email.

Begin!

Question: {input}
{agent_scratchpad}"""

# sql_db_schema = Tool(
#     name="sql_db_schema",
#     func=lambda _:  db.get_table_info,
#     description="Use this tool to list all schema in the database. Input should be an empty string.",
# )

# sql_db_list_tables = Tool(
#     name="sql_db_list_tables",
#     func=lambda _:  db.get_table_names(),
#     description="Use this tool to list all tables in the database. Input should be an empty string.",
# )

# sql_db_query = Tool(
#     name="sql_db_query",
#     func=lambda query: db.run(query),
#     description="Use this tool to execute any SQL query on the database.",
# )
# sql_db_query_checker = Tool(
#     name="sql_db_query_checker",
#     func=lambda query: db.run(query),
#     description="Check the  SQL query on the database.",
# )
# tools = [sql_db_list_tables, sql_db_query,sql_db_schema,sql_db_query_checker]
# tool_names = [tool.name for tool in tools]
# print("Available tools:", tool_names)


def db_create():
    db: SQLDatabase = SQLDatabase.from_uri(
        "postgresql+psycopg2://sorgente:sorgente@192.168.1.98:5432/sorgente"
    )
    return db
    # tables = db.get_table_names()
    # print("db :", tables)


def llm_create():
    llm = ChatOpenAI(
        model="deepseek-coder-1.3b-instruct",
        openai_api_base="http://192.168.1.98:8000/v1",
        openai_api_key="EMPTY",  # vllm ignores this
        verbose=True,
        # tools=tools,
    )
    return llm


@app.get("/sql-agent")
def run_sql(query: str = Query(..., description="Natural language question")):
    print(query)
    try:

        reasoning_logger = ReasoningLogger()
        logger = StdOutCallbackHandler()  # stampa tutto sulla console

        db1 = db_create()
        llm1 = llm_create()

        sql_agent_executor = create_sql_agent(
            llm=llm1,
            db=db1,
            # tools=tools,
            agent_type="zero-shot-react-description",
            prompt=PromptTemplate.from_template(CUSTOM_SQL_PROMPT),
            verbose=True,
            handle_parsing_errors=True,
            callbacks=[reasoning_logger, logger],
        )


        result = sql_agent_executor.invoke({"input": query})
        
        # r = prompt.invoke({ "input": query})
        # print("Prompt:", r)
        # chain = prompt | sql_agent_executor
        # result = chain.invoke({"input": query})
        
        agent_reasoning = reasoning_logger.logs

        print("Result:", result)
        print("LLM Reasoning:", agent_reasoning)
        return {
            "query": query,
            "input": query,
            "output": result.get("output"),
            "result": result,
            "reasoning": agent_reasoning,
        }
    except Exception as e:
        agent_reasoning = reasoning_logger.logs
        print("LLM Reasoning:", agent_reasoning)
        resp = {"reasoning": agent_reasoning, "error": str(e)}
        print("error", resp)
        raise e
        return resp


@app.get("/langchain")
def use_langchain(query: str):
    prompt = PromptTemplate(
        template="Write a Python function that {task}", input_variables=["task"]
    )
    chain = prompt | llm_create()
    return {"result": chain.invoke({"task": query})}


# @tool("ping")
# def ping_tool() -> str:
#     """Simple ping tool that returns 'pong'."""
#     return "pong"
# @tool("crawl_web")
# def crawl_web(url: str) -> str:
#     """Fetch and extract text from a web page"""
#     resp = requests.get(url, timeout=10)
#     soup = BeautifulSoup(resp.text, "html.parser")
#     return soup.get_text()[:2000]  # limit for token safety
# tools = [
#     ping_tool,
#     crawl_web
#     # , sql_agent_executor
# ]

# agent = initialize_agent(
#     tools, llm, agent=AgentType.OPENAI_FUNCTIONS,  verbose=True
# )
# agent: AgentExecutor = initialize_agent(
#     tools=tools,
#     llm=llm,
#     agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
#     verbose=True,
#     tool_choice="auto",
#     enable_auto_tool_choice=True,
#     tool_call_parser=True,
# )


@app.get("/sql-test")
async def run_sql():
    print("Testing SQL connection...")
    try:
        db_test()
        return {"status": "success"}
    except Exception as e:
        print("error", e)
        return {"error": str(e)}


def db_test():
    global db
    try:
        print("Connection testing!")
        tables = db.get_table_names()
        selectTest = db.run("SELECT 1")
        print("SQLAlchemy connection successful!", tables, selectTest)
        conn = psycopg2.connect(
            host="192.168.1.98",
            port=5432,
            dbname="sorgente",
            user="sorgente",
            password="sorgente",
        )
        print("Connection successful!")
        conn.close()
    except Exception as e:
        print("Connection failed:", e)


# Define a simple Guardrail schema
rail_spec = """
# Output must be JSON with:
{
  "function_name": "str",
  "code": "str"
}
"""

# llm = VLLM(model="TheBloke/Llama-2-7b-chat-hf", trust_remote_code=True)

# guard = Guard.from_rail_string(rail_spec, llm=llm)

# class FunctionWriter(dspy.Signature):
#     task = dspy.InputField()
#     code = dspy.OutputField()

# def generate_code(task: str) -> str:
#     response = guard(task)
#     return response["code"]

# generator = dspy.ChainOfThought(FunctionWriter, fn=generate_code)
# print(generator(task="reverse a string").code)


# sql_agent_executor = create_sql_agent(llm=llm, db=db, agent_type="openai-tools"  , verbose=True)


# //crawl_web
# tools = [sql_agent_executor]
# agent = initialize_agent(
#     tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True
# )


# # DSPy -> same vLLM endpoint
# dspy.settings.configure(
#     lm=dspy.LM("openai/deepseek-coder-1.3b",
#                api_base="http://vllm-deepseek:8000/v1",
#                api_key="EMPTY")
# )

# @app.geresult": response }

# @app.get("/dspy")
# def use_dspy(query: str):
#     class FunctionWriter(dspy.Signature):
#         """Write a Python function."""
#         task = dspy.InputField()
#         code = dspy.OutputField()
#     generator = dspy.ChainOfThought(FunctionWriter)
#     return {"result": generator(task=query).code}
